CREATE TABLE your_api_table (
  component VARCHAR2(100),
  request_type VARCHAR2(10),
  url VARCHAR2(500),
  email VARCHAR2(100)
);


import requests
import pandas as pd
import time
from concurrent.futures import ThreadPoolExecutor
from sqlalchemy import create_engine

# Database connection details
db_username = 'your_username'
db_password = 'your_password'
db_host = 'your_host'
db_port = 'your_port'
db_name = 'your_database_name'
api_table = 'your_api_table'

# API table column names
component_column = 'component'
request_type_column = 'request_type'
url_column = 'url'
email_column = 'email'

# Function to check API health
def check_api_health(api_row):
    component = api_row[component_column]
    request_type = api_row[request_type_column]
    url = api_row[url_column]
    email = api_row[email_column]

    start_time = time.time()
    try:
        if request_type.upper() == 'GET':
            response = requests.get(url)
        elif request_type.upper() == 'POST':
            response = requests.post(url)
        else:
            return [component, request_type, url, 'Invalid request type', email]

        elapsed_time = time.time() - start_time
        if response.status_code == 200:
            health = 'UP'
        else:
            health = 'DOWN'

        if elapsed_time > 30:
            health += ' (Delayed Response)'
    except requests.exceptions.RequestException as e:
        elapsed_time = time.time() - start_time
        health = f'DOWN (Exception: {str(e)})'

    return [component, request_type, url, health, elapsed_time, email]


# Database connection URL
db_url = f'oracle+cx_oracle://{db_username}:{db_password}@{db_host}:{db_port}/{db_name}'

# Create SQLAlchemy engine
engine = create_engine(db_url)

# Retrieve API information from the table
query = f"SELECT {component_column}, {request_type_column}, {url_column}, {email_column} FROM {api_table}"
api_df = pd.read_sql(query, engine)

# Close the SQLAlchemy engine
engine.dispose()

# Check API health in parallel
with ThreadPoolExecutor(max_workers=10) as executor:
    results = executor.map(check_api_health, api_df.to_dict(orient='records'))

# Generate report using pandas DataFrame
report_columns = [component_column, request_type_column, url_column, 'Health', 'Elapsed Time', email_column]
report_data = list(results)
report_df = pd.DataFrame(report_data, columns=report_columns)

# Display the report
print(report_df)



import datetime
import pytz

# Get the current datetime in APAC timezone
apac_timezone = pytz.timezone('Asia/Kolkata')  # Replace with the appropriate APAC timezone
apac_datetime = datetime.datetime.now(apac_timezone)

# Get the current datetime in EST timezone
est_timezone = pytz.timezone('America/New_York')  # Replace with the appropriate EST timezone
est_datetime = datetime.datetime.now(est_timezone)

# Check if it's a weekend in APAC
is_weekend_apac = apac_datetime.weekday() in [5, 6]  # Saturday is 5, Sunday is 6

# Check if it's a weekend in EST
is_weekend_est = est_datetime.weekday() in [5, 6]  # Saturday is 5, Sunday is 6

# Example usage
if is_weekend_apac and is_weekend_est:
    print("It's the weekend in both APAC and EST. Health check will be turned off.")
else:
    print("Health check will be performed.")


from fastapi import FastAPI, Request
from opentelemetry import trace
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.propagate import extract, inject
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import ConsoleSpanExporter
from opentelemetry.sdk.trace.export import BatchExportSpanProcessor
from opentelemetry.trace import SpanKind, get_tracer
from opentelemetry.trace.propagation.tracecontext import TraceContextTextMapPropagator

app = FastAPI()

# Initialize Jaeger exporter and set it as the span processor
span_exporter = ConsoleSpanExporter()
span_processor = BatchExportSpanProcessor(span_exporter)
trace.get_tracer_provider().add_span_processor(span_processor)

# Initialize the tracer with the Jaeger exporter
tracer_provider = TracerProvider()
trace.set_tracer_provider(tracer_provider)

# Configure the propagator to extract and inject trace context from headers
trace.set_global_textmap(TraceContextTextMapPropagator())

# Instrument FastAPI app
FastAPIInstrumentor.instrument_app(app)

# Middleware to handle tracing
@app.middleware("http")
async def handle_trace(request: Request, call_next):
    # Extract the trace context from headers
    context = extract(request.headers)

    # If trace context not present, generate new trace and inject it
    if context is None:
        with tracer_provider.get_tracer(__name__).start_as_current_span("HTTP request",
                                                                         kind=SpanKind.SERVER) as span:
            # Set additional tags, if needed
            span.set_attribute("http.method", request.method)
            span.set_attribute("http.url", str(request.url))

            # Inject the trace context into the response headers
            inject(span.get_span_context(), request.headers)

            response = await call_next(request)
            span.set_attribute("http.status_code", response.status_code)
            return response

    # If trace context present, continue with the existing trace
    with tracer_provider.get_tracer(__name__).start_as_current_span("HTTP request",
                                                                     context=context,
                                                                     kind=SpanKind.SERVER) as span:
        # Set additional tags, if needed
        span.set_attribute("http.method", request.method)
        span.set_attribute("http.url", str(request.url))

        response = await call_next(request)
        span.set_attribute("http.status_code", response.status_code)
        return response

# Routes
@app.get("/")
async def root():
    return {"message": "Hello, World!"}

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
